<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Team Collaboration</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" rel="stylesheet">
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #10b981;
            --secondary-dark: #059669;
            --light: #f9fafb;
            --dark: #1f2937;
            --gray: #9ca3af;
            --light-gray: #e5e7eb;
            --user-msg: #a5f3fc;
            --user-msg-dark: #0891b2;
            --agent-msg: #e0f2fe;
            --agent-msg-dark: #0369a1;
            --error: #fee2e2;
            --error-dark: #b91c1c;
            --report: #dbeafe;
            --report-dark: #1d4ed8;
            --success: #d1fae5; /* Added success color */
            --success-dark: #065f46; /* Added success dark color */
            --info: #e0f2fe; /* Added info color */
            --info-dark: #075985; /* Added info dark color */
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            transition: var(--transition);
        }

        .container {
            width: 90%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            background-color: var(--light);
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            overflow: hidden; /* Prevents children from overflowing rounded corners */
            position: relative; /* Needed for absolute positioning context if required */
            transition: var(--transition);
            animation: fadeInUp 0.6s ease-out;
        }

        @keyframes fadeInUp {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .header {
            background: linear-gradient(to right, var(--primary), var(--primary-dark));
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        #toggle-settings {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: var(--transition);
        }

        #toggle-settings:hover {
            background-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        #chat-container {
            display: flex;
            flex-direction: column;
            height: 70vh;
            position: relative; /* Keep relative for internal absolute elements like error popup if needed */
            padding: 20px;
        }

        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            scrollbar-width: thin;
            scrollbar-color: var(--gray) transparent;
        }

        #chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        #chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }

        #chat-messages::-webkit-scrollbar-thumb {
            background-color: var(--gray);
            border-radius: 3px;
        }

        #chat-input {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            position: relative;
        }

        #user-message {
            flex: 1;
            padding: 14px 20px;
            font-size: 1rem;
            border: 1px solid var(--light-gray);
            border-radius: 12px;
            outline: none;
            transition: var(--transition);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        #user-message:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }

        #send-button {
            background: linear-gradient(to right, var(--primary), var(--primary-dark));
            color: white;
            border: none;
            border-radius: 12px;
            padding: 0 24px;
            font-size: 1rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        #send-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
        }

        .message {
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            animation: fadeIn 0.3s ease-out;
            line-height: 1.5;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .user-message {
            background: linear-gradient(135deg, var(--user-msg), var(--user-msg) 80%);
            color: var(--dark);
            align-self: flex-end;
            border-bottom-right-radius: 0;
        }

        .agent-message {
            background: linear-gradient(135deg, var(--agent-msg), var(--agent-msg) 80%);
            color: var(--dark);
            align-self: flex-start;
            border-bottom-left-radius: 0;
        }
        /* Style for system messages within chat */
        .system-message {
            background-color: var(--light-gray);
            color: var(--dark);
            font-style: italic;
            align-self: center; /* Center system messages */
            max-width: 90%; /* Allow wider system messages */
            border-radius: 8px; /* Smaller radius for system */
            text-align: center;
        }
        body.dark-mode .system-message {
            background-color: #374151;
            color: var(--light-gray);
        }


        .agent-role {
            font-weight: 600;
            color: var(--agent-msg-dark);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        body.dark-mode .agent-role {
           color: var(--user-msg); /* Adjust for dark mode if needed */
        }
         /* Adjust system role color in dark mode */
        body.dark-mode .system-message .agent-role {
           color: #9ca3af;
        }


        /* Error Message Box (Separate from Toast) */
        #error-popup-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 800px;
            z-index: 100;
            display: none;
            flex-direction: column;
            align-items: center;
        }

        .error-message-box {
            background: linear-gradient(135deg, var(--error), var(--error) 80%);
            color: var(--error-dark);
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 10px;
            word-wrap: break-word;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            animation: shakeError 0.4s ease-in-out;
            text-align: center;
            width: 100%; /* Take full width of container */
        }

        @keyframes shakeError {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); }
            20%, 40%, 60%, 80% { transform: translateX(8px); }
        }

        .error-close-button {
            background-color: var(--error-dark);
            color: var(--light);
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        /* {{Additions for Confirmation Popup}} */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Dim background */
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 1005; /* Above toasts */
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .popup-overlay.show {
            display: flex;
            opacity: 1;
        }

        .popup-content {
            background-color: var(--light);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 400px;
            width: 90%;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        .popup-overlay.show .popup-content {
             transform: scale(1);
        }
        body.dark-mode .popup-content {
             background-color: var(--dark);
             color: var(--light);
        }


        .popup-content p {
            margin-bottom: 20px;
            font-size: 1.1rem;
            line-height: 1.6;
             color: var(--dark); /* Default text color */
        }
        body.dark-mode .popup-content p {
             color: var(--light); /* Text color in dark mode */
        }

        .popup-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .popup-button {
            padding: 10px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .popup-button.yes {
            background: linear-gradient(to right, var(--secondary), var(--secondary-dark));
            color: white;
        }
        .popup-button.no {
            background-color: var(--light-gray);
            color: var(--dark);
            border: 1px solid var(--gray);
        }
         body.dark-mode .popup-button.no {
             background-color: #374151;
             color: var(--light);
             border-color: #4b5563;
         }

        .popup-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
         .popup-button.no:hover {
            background-color: #d1d5db;
         }
         body.dark-mode .popup-button.no:hover {
             background-color: #4b5563;
         }
        /* {{End Confirmation Popup Styles}} */

        .error-close-button:hover {
            background-color: var(--error);
            color: var(--error-dark);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        /* End Error Message Box */


        .final-report {
            margin-top: 20px;
            border: 1px solid var(--light-gray);
            padding: 20px;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--report), var(--report) 80%);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            animation: expandReport 0.5s ease-out;
        }

        @keyframes expandReport {
            from {
                opacity: 0;
                max-height: 0;
                padding: 0 20px;
            }
            to {
                opacity: 1;
                max-height: 1000px; /* Adjust if needed */
                padding: 20px;
            }
        }

        .final-report-title {
            font-weight: 600;
            color: var(--report-dark);
            margin-bottom: 10px;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #settings-container {
            padding: 24px;
            display: none;
            border-top: 1px solid var(--light-gray);
            animation: slideDown 0.4s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #settings-container h2 {
            color: var(--dark);
            margin-bottom: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #settings-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .settings-section {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--light-gray);
        }
        body.dark-mode .settings-section {
            border-bottom-color: #374151;
        }
        .settings-section:last-of-type {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .settings-section h3 {
            color: var(--dark);
            margin-bottom: 15px;
            font-weight: 500;
            font-size: 1.1rem;
            padding-bottom: 8px;
             display: flex;
             align-items: center;
             gap: 8px;
        }
        body.dark-mode .settings-section h3 {
            color: white;
        }


        #settings-content label {
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
            color: var(--dark);
            font-weight: 500;
        }

        #settings-content input[type="text"],
        #settings-content textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--light-gray);
            border-radius: 8px;
            font-size: 0.9rem;
            transition: var(--transition);
        }

        #settings-content input[type="text"]:focus,
        #settings-content textarea:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
            outline: none;
        }

        #settings-content textarea {
            resize: vertical;
            min-height: 100px;
            line-height: 1.5;
        }

        .settings-role-group {
            border: 1px solid var(--light-gray);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            background-color: #fff;
        }
        body.dark-mode .settings-role-group {
            border-color: #374151;
            background-color: #1f2937;
        }
        .settings-role-group h4 {
            margin-bottom: 10px;
            font-weight: 600;
            color: var(--primary);
        }
        body.dark-mode .settings-role-group h4 {
            color: #a5b4fc;
        }
        .settings-role-group label {
            margin-top: 10px;
            font-weight: 500;
        }

        .remove-role-button {
            background-color: var(--error);
            color: var(--error-dark);
            border: 1px solid var(--error-dark);
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            margin-top: 15px;
            transition: background-color 0.2s ease;
        }
        .remove-role-button:hover {
            background-color: #fecaca;
        }
        body.dark-mode .remove-role-button {
            background-color: #b91c1c;
            color: #fee2e2;
            border-color: #fee2e2;
        }
        body.dark-mode .remove-role-button:hover {
            background-color: #991b1b;
        }
        #add-new-role-button {
            background: linear-gradient(to right, var(--secondary), var(--secondary-dark));
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 18px;
            font-size: 0.95rem;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            margin-top: 15px; /* Ensure spacing */
        }
        #add-new-role-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
        }
        .new-custom-role-input {
            border-color: var(--secondary);
        }
        body.dark-mode .new-custom-role-input {
            border-color: var(--secondary-dark);
        }

        #save-settings {
            background: linear-gradient(to right, var(--secondary), var(--secondary-dark));
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 1rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            margin-top: 20px; /* Add margin if needed */
        }

        #save-settings:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
        }

        /* Agent Role Icons */
        .role-icon {
            font-size: 0.9rem;
            width: 22px;
            height: 22px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background-color: var(--agent-msg-dark);
            color: white;
        }
        body.dark-mode .role-icon {
           /* Adjust icon background if needed */
           background-color: var(--user-msg-dark);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                width: 95%;
            }
            #chat-container {
                height: 65vh; /* Slightly adjust */
            }
            .message {
                max-width: 90%;
            }
            #settings-content {
                grid-template-columns: 1fr;
            }
            .header h1 {
                 font-size: 1.3rem;
            }
            #toggle-settings {
                 padding: 6px 12px;
                 font-size: 0.8rem;
            }
            #user-message {
                 padding: 12px 15px;
            }
            #send-button {
                 padding: 0 18px;
            }
             /* Adjust toast width on smaller screens */
             .toast {
                 width: 90%;
                 max-width: none;
             }
        }

        /* Dark Mode Toggle */
        .dark-mode-toggle {
            position: absolute;
            top: 20px;
            right: 20px; /* Ensure it doesn't overlap settings button */
            background: none;
            border: none;
            color: var(--gray);
            cursor: pointer;
            font-size: 1.2rem;
            z-index: 10;
            transition: var(--transition);
        }

        .dark-mode-toggle:hover {
            color: var(--dark);
            transform: rotate(30deg);
        }

        /* Dark Mode Styles */
        body.dark-mode {
            background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
        }

        body.dark-mode .container {
            background-color: #111827;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        body.dark-mode #user-message {
            background-color: #1f2937;
            border-color: #374151;
            color: white;
        }
        body.dark-mode #user-message::placeholder {
            color: var(--gray);
        }

        body.dark-mode .message,
        body.dark-mode .final-report {
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        /* Adjust message colors for dark mode */
         body.dark-mode .user-message {
             background: linear-gradient(135deg, #0e7490, #155e75); /* Darker user msg */
             color: var(--light);
         }
         body.dark-mode .agent-message {
             background: linear-gradient(135deg, #1e3a8a, #1e40af); /* Darker agent msg */
             color: var(--light);
         }
         body.dark-mode .final-report {
             background: linear-gradient(135deg, #1e3a8a, #1e40af);
             border-color: #374151;
             color: var(--light);
         }
         body.dark-mode .final-report-title {
             color: #93c5fd; /* Lighter blue for title */
         }


        body.dark-mode #settings-container {
            background-color: #111827;
            border-top-color: #374151;
        }

        body.dark-mode #settings-content label {
            color: white;
        }

        body.dark-mode #settings-content input[type="text"],
        body.dark-mode #settings-content textarea {
            background-color: #1f2937;
            border-color: #374151;
            color: white;
        }
        body.dark-mode #settings-content input[type="text"]::placeholder,
        body.dark-mode #settings-content textarea::placeholder {
             color: var(--gray);
        }

        body.dark-mode h2,
        body.dark-mode .dark-mode-toggle {
            color: white;
        }
        body.dark-mode .dark-mode-toggle:hover {
             color: var(--light-gray);
        }

        /* Loading Animation */
        .loading {
            display: none;
            justify-content: center;
            margin: 20px 0;
        }

        .loading-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--primary);
            margin: 0 5px;
            animation: loading 1.4s infinite ease-in-out both;
        }

        .loading-dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .loading-dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes loading {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        /* Tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* {{Change 1: Styles for Toast Notifications}} */
        @keyframes toastShake {
            0%, 100% { transform: translateX(0); }
            25%, 75% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
        }

        .toast {
            position: fixed; /* Changed from relative/absolute */
            top: 20px;       /* Position from top */
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            min-width: 300px;
            max-width: 600px;
            padding: 15px 40px 15px 20px; /* Make space for close button */
            color: white;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 1001; /* Ensure it's above other elements */
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0; /* Start hidden for animation */
            /* Removed right/bottom positioning */
        }
        .toast.show {
             opacity: 1;
             /* Apply shake animation together with entrance */
             animation: animate__fadeInDown 0.5s ease-out, toastShake 0.4s 0.5s ease-in-out; /* Fade in, then shake */
        }
        .toast.hide {
             animation: animate__fadeOutUp 0.5s ease-in forwards; /* Fade out upwards */
        }

        .toast-icon {
            font-size: 1.2rem;
        }

        .toast-message {
            flex-grow: 1;
            font-size: 0.95rem;
        }

        .toast-close {
            position: absolute;
            top: 5px;
            right: 10px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            padding: 5px;
        }
        .toast-close:hover {
            color: white;
        }

        .toast-success { background: linear-gradient(to right, var(--secondary), var(--secondary-dark)); }
        .toast-error { background: linear-gradient(to right, var(--error-dark), #991b1b); } /* Darker error */
        .toast-info { background: linear-gradient(to right, var(--info-dark), #0369a1); } /* Darker info */
        /* Add styles for dark mode toast if needed */


    </style>
</head>
<body>
    <!-- Container and existing elements -->
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-robot"></i> AI Team Collaboration</h1>
            <button id="toggle-settings"><i class="fas fa-cog"></i> Settings</button>
        </div>

        <button class="dark-mode-toggle tooltip">
            <i class="fas fa-moon"></i>
            <span class="tooltiptext">Toggle Dark Mode</span>
        </button>

        <div id="chat-container">
             <!-- Error popup container (stays relative to chat-container if needed) -->
             <div id="error-popup-container"></div>
             <!-- Chat messages area -->
            <div id="chat-messages"></div>
            <!-- Loading indicator -->
            <div class="loading">
                <div class="loading-dot"></div>
                <div class="loading-dot"></div>
                <div class="loading-dot"></div>
            </div>
            <!-- Input area -->
            <div id="chat-input">
                <input type="text" id="user-message" placeholder="Enter your problem...">
                <button id="send-button"><i class="fas fa-paper-plane"></i> Send</button>
            </div>
        </div>

        <!-- Settings Panel -->
        <div id="settings-container">
            <h2><i class="fas fa-sliders-h"></i> Settings</h2>
            <div id="settings-content">
                 <!-- Settings content will be populated by JS -->
            </div>
            <button id="save-settings"><i class="fas fa-save"></i> Save Settings</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
          // --- Existing Variables ---
          const userMessageInput = document.getElementById('user-message');
          const sendButton = document.getElementById('send-button');
          const chatMessages = document.getElementById('chat-messages');
          const settingsContainer = document.getElementById('settings-container');
          const toggleSettingsButton = document.getElementById('toggle-settings');
          const saveSettingsButton = document.getElementById('save-settings');
          const settingsContent = document.getElementById('settings-content');
          const darkModeToggle = document.querySelector('.dark-mode-toggle');
          const loadingIndicator = document.querySelector('.loading');
          // Get error popup container element
          const errorPopupContainer = document.getElementById('error-popup-container');

          // --- Constants and Initial Settings ---
          const GOOGLE_API_KEY = "YOUR_API_KEY"; // *** REPLACE WITH YOUR KEY ***
          const DEFAULT_ROUNDS = 3;
          const DEFAULT_ROLES = ['leader', 'researcher', 'analyst', 'critic', 'synthesizer', 'reporter'];

          // Model provider configurations
          const MODEL_PROVIDERS = {
            google: {
              name: "Google Gemini",
              apiKeyPrefix: "",
              models: {
                "gemini-2.0-flash-lite-001": "Flash Lite",
                "gemini-pro": "Gemini Pro",
                "gemini-ultra": "Gemini Ultra"
              }
            },
            openai: {
              name: "OpenAI",
              apiKeyPrefix: "sk-",
              models: {
                "gpt-3.5-turbo": "GPT-3.5 Turbo",
                "gpt-4": "GPT-4",
                "gpt-4-turbo": "GPT-4 Turbo"
              }
            }
          };

          // Default provider for each role
          const DEFAULT_PROVIDERS = {
            "leader": "google",
            "researcher": "google",
            "analyst": "google",
            "critic": "google",
            "synthesizer": "google",
            "reporter": "google"
          };

          // API endpoints for different providers
          const API_ENDPOINTS = {
            google: (model) => `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`,
            openai: () => `https://api.openai.com/v1/chat/completions`
          };

          // Default API keys for each provider
          const DEFAULT_API_KEYS = {
            google: GOOGLE_API_KEY,
            openai: "YOUR_OPENAI_API_KEY" // Placeholder for OpenAI
          };

          const MODEL_TYPES = {
              "leader": "gemini-2.0-flash-lite-001",
              "researcher": "gemini-2.0-flash-lite-001",
              "analyst": "gemini-2.0-flash-lite-001",
              "critic": "gemini-2.0-flash-lite-001",
              "synthesizer": "gemini-2.0-flash-lite-001",
              "reporter": "gemini-2.0-flash-lite-001",
          };

          // --- PLACEHOLDER: Add your FULL default system prompts here ---
          const DEFAULT_SYSTEM_PROMPTS = {
               "leader": `You are the Leader... [Your Full Prompt Here]`,
               "researcher": `You are the Researcher... [Your Full Prompt Here]`,
               "analyst": `You are the Analyst... [Your Full Prompt Here]`,
               "critic": `You are the Critic... [Your Full Prompt Here]`,
               "synthesizer": `You are the Synthesizer... [Your Full Prompt Here]`,
               "reporter": `You are the Reporter... [Your Full Prompt Here]`,
          };
          // -------------------------------------------------------------

          let settings = {
              api_keys: { google: GOOGLE_API_KEY },
              model_providers: { ...DEFAULT_PROVIDERS },
              model_types: { ...MODEL_TYPES },
              system_prompts: { ...DEFAULT_SYSTEM_PROMPTS },
              max_rounds: DEFAULT_ROUNDS
          };
          let activeToast = null; // Track the currently active toast

          // --- Dark Mode ---
           darkModeToggle.addEventListener('click', () => {
                document.body.classList.toggle('dark-mode');
                const isDarkMode = document.body.classList.contains('dark-mode');
                darkModeToggle.innerHTML = isDarkMode ?
                    '<i class="fas fa-sun"></i><span class="tooltiptext">Toggle Light Mode</span>' :
                    '<i class="fas fa-moon"></i><span class="tooltiptext">Toggle Dark Mode</span>';
                localStorage.setItem('darkMode', isDarkMode);
                // Re-apply system message styles if needed
                document.querySelectorAll('.system-message').forEach(el => {
                    if (isDarkMode) {
                        el.style.backgroundColor = '#374151';
                        el.style.color = 'var(--light-gray)';
                        const roleEl = el.querySelector('.agent-role');
                        if (roleEl) roleEl.style.color = '#9ca3af';
                    } else {
                        el.style.backgroundColor = 'var(--light-gray)';
                        el.style.color = 'var(--dark)';
                        const roleEl = el.querySelector('.agent-role');
                        if (roleEl) roleEl.style.color = '#4b5563';
                    }
                });
            });
            if (localStorage.getItem('darkMode') === 'true') {
                document.body.classList.add('dark-mode');
                darkModeToggle.innerHTML = '<i class="fas fa-sun"></i><span class="tooltiptext">Toggle Light Mode</span>';
            }
           // --- End Dark Mode ---


          // --- Helper Functions ---

            async function generate_response(provider, model_name, system_prompt, user_content) {
                // Get API key based on provider
                const apiKey = settings.api_keys[provider];
                if (!apiKey || apiKey === "YOUR_API_KEY" || apiKey.trim() === "") {
                     console.error(`${provider} API key is missing or invalid in settings.`);
                     return [null, `${provider.charAt(0).toUpperCase() + provider.slice(1)} API key is missing or invalid. Please configure it in Settings.`];
                }

                // Prepare request based on provider
                let url, requestBody, headers;
                if (provider === 'google') {
                    url = `${API_ENDPOINTS.google(model_name)}?key=${apiKey}`;
                    requestBody = {
                         contents: [{
                             role: "user",
                             parts: [{ text: `${system_prompt}\n\n---\n\n${user_content}` }]
                         }],
                    };
                    headers = { 'Content-Type': 'application/json' };
                } else if (provider === 'openai') {
                    url = API_ENDPOINTS.openai();
                    requestBody = {
                        model: model_name,
                        messages: [
                            { role: "system", content: system_prompt },
                            { role: "user", content: user_content }
                        ],
                        temperature: 0.7,
                        max_tokens: 2048
                    };
                    headers = { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    };
                } else {
                    return [null, `Unsupported provider: ${provider}`];
                }

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(requestBody),
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        const errorMessage = errorData.error?.message || `HTTP error! Status: ${response.status}`;
                        console.error(`API Error for ${provider}/${model_name}:`, errorMessage, errorData);
                        throw new Error(`API Error (${response.status}): ${errorMessage}`);
                    }

                    const data = await response.json();

                    // Handle responses based on provider
                    if (provider === 'google') {
                        // Check for content blocking
                        if (data.promptFeedback?.blockReason) {
                             console.warn(`Content blocked for ${provider}/${model_name}: ${data.promptFeedback.blockReason}`);
                             return [null, `Content blocked by API policy: ${data.promptFeedback.blockReason}`];
                        }
                        // Check for valid response content
                        if (data.candidates && data.candidates.length > 0 && data.candidates[0].content?.parts?.length > 0) {
                             const finishReason = data.candidates[0].finishReason;
                             if (finishReason && !["STOP", "MAX_TOKENS"].includes(finishReason)) {
                                 console.warn(`Unusual finish reason for ${provider}/${model_name}: ${finishReason}`);
                                 if (finishReason === "SAFETY") {
                                     return [null, "Response partially generated but stopped due to safety settings."];
                                 }
                             }
                             return [data.candidates[0].content.parts[0].text.trim(), null];
                         }
                    } else if (provider === 'openai') {
                        if (data.choices && data.choices.length > 0 && data.choices[0].message?.content) {
                            return [data.choices[0].message.content.trim(), null];
                        }
                    }

                    // Handle cases where API returns 200 OK but no valid content
                    console.warn("API returned OK but with empty or invalid response structure:", data);
                    return [null, "No valid response content received from the API."];
                } catch (error) {
                    console.error(`Error calling ${provider} API for ${model_name}:`, error);
                    return [null, error.message || "An unexpected error occurred during the API call."];
                }
            }

            async function run_agent(role, task_prompt, collaboration_state) {
                const model_name = settings.model_types[role];
                const provider = settings.model_providers[role] || 'google';
                const system_prompt = settings.system_prompts[role];
                if (!model_name || !system_prompt) {
                     const errorMsg = `Settings for role "${role}" are missing. Cannot run agent.`;
                     console.error(errorMsg);
                     displayErrorMessage(errorMsg, 'System'); // Use the dedicated error popup
                     return [null, errorMsg]; // Return error state
                }

                let agent_input = `**Current Task:**\n${task_prompt}\n\n`;
                agent_input += `**Overall User Problem:**\n${collaboration_state.original_problem}\n\n`;
                if (collaboration_state.summary) {
                    agent_input += `**Current Summary/State:**\n${collaboration_state.summary}\n\n`;
                }
                if (collaboration_state.history && collaboration_state.history.length > 0) {
                    agent_input += `**Recent History:**\n`;
                    // Include last few interactions for context, prevent infinite growth
                    const historySlice = collaboration_state.history.slice(-3);
                    historySlice.forEach(h => {
                       agent_input += ` - ${h.role}: ${h.content.substring(0,150)}...\n`;
                    });
                }


                displayMessage(`*Tasking ${role}: ${task_prompt.substring(0, 100)}...*`, 'system'); // Display system message in chat

                const [response, error] = await generate_response(provider, model_name, system_prompt, agent_input);

                if (error) {
                    displayErrorMessage(error, role); // Display error in the popup
                    return [null, error]; // Propagate error
                }

                if (response) {
                    displayMessage(response, role); // Display successful response in chat
                    collaboration_state.history = collaboration_state.history || [];
                    collaboration_state.history.push({ role: role, content: response });
                    return [response, null]; // Return success state
                } else {
                    // Handle case where API might return [null, null] unexpectedly
                    const nullErrorMsg = "Agent received an empty response without an explicit error.";
                    displayErrorMessage(nullErrorMsg, role);
                    return [null, nullErrorMsg];
                }
            }

            function getRoleIcon(role) {
                const icons = {
                    'leader': '<i class="fas fa-crown"></i>', 'researcher': '<i class="fas fa-search"></i>',
                    'analyst': '<i class="fas fa-chart-line"></i>', 'critic': '<i class="fas fa-comments"></i>',
                    'synthesizer': '<i class="fas fa-puzzle-piece"></i>', 'reporter': '<i class="fas fa-newspaper"></i>',
                    'system': '<i class="fas fa-cogs"></i>' // Icon for system messages
                };
                const defaultIcon = '<i class="fas fa-user-secret"></i>'; // Default for unknown/custom roles
                const isSystem = role === 'system';
                // Use a neutral color for system icon, agent color otherwise
                const iconBgColor = isSystem
                    ? (document.body.classList.contains('dark-mode') ? '#4b5563' : '#d1d5db')
                    : (document.body.classList.contains('dark-mode') ? 'var(--user-msg-dark)' : 'var(--agent-msg-dark)');
                 const iconColor = isSystem
                    ? (document.body.classList.contains('dark-mode') ? '#e5e7eb' : '#374151')
                    : 'white';

                return `<span class="role-icon" style="background-color: ${iconBgColor}; color: ${iconColor};">${icons[role] || defaultIcon}</span>`;
            }


            function displayMessage(message, sender) {
                const messageElement = document.createElement('div');
                messageElement.classList.add('message');
                const isUser = sender === 'user';
                const isSystem = sender === 'system';

                if (isUser) {
                    // Sanitize user input before setting textContent to prevent XSS if message structure changes
                    messageElement.textContent = message;
                    messageElement.classList.add('user-message');
                } else {
                    // Agent or System message
                    messageElement.classList.add(isSystem ? 'system-message' : 'agent-message');

                    // Role indicator
                    const roleElement = document.createElement('div');
                    roleElement.classList.add('agent-role');
                    // Capitalize sender name for display
                    const displayName = sender.charAt(0).toUpperCase() + sender.slice(1);
                    roleElement.innerHTML = `${getRoleIcon(sender)} ${displayName}`;
                    messageElement.appendChild(roleElement);

                     // Apply specific styles for system messages via CSS class '.system-message' (already defined)

                    // Message content (handle potential HTML/Markdown carefully)
                    const contentElement = document.createElement('div');
                    // Basic formatting - consider a safer Markdown parser if complex formatting is needed
                     contentElement.innerHTML = message
                        .replace(/&/g, "&amp;") // Basic sanitization first
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                        .replace(/\*(.*?)\*/g, '<em>$1</em>')     // Italic
                        .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>') // Code blocks
                        .replace(/`([^`]+)`/g, '<code>$1</code>') // Inline code
                        .replace(/\n/g, '<br>'); // Newlines
                    messageElement.appendChild(contentElement);
                }

                chatMessages.appendChild(messageElement);
                // Scroll to bottom smoothly
                chatMessages.scrollTo({ top: chatMessages.scrollHeight, behavior: 'smooth' });
                // Add entrance animation
                messageElement.classList.add('animate__animated', 'animate__fadeIn');
            }

             // Uses the dedicated error popup container at the top of the chat
            function displayErrorMessage(error, role) {
                errorPopupContainer.innerHTML = ''; // Clear previous error
                errorPopupContainer.style.display = 'flex'; // Show the container

                const messageBox = document.createElement('div');
                messageBox.classList.add('error-message-box'); // Basic styling class
                 // messageBox.classList.add('animate__animated', 'animate__shakeX'); // Add shake animation from animate.css
                messageBox.innerHTML = `<strong><i class="fas fa-exclamation-triangle"></i> Error (${role || 'System'}):</strong> ${error}`;
                errorPopupContainer.appendChild(messageBox);

                const closeButton = document.createElement('button');
                closeButton.classList.add('error-close-button');
                closeButton.textContent = 'Close';
                closeButton.addEventListener('click', () => {
                    errorPopupContainer.style.display = 'none'; // Hide the container on close
                    errorPopupContainer.innerHTML = ''; // Clear content
                });
                errorPopupContainer.appendChild(closeButton);

                 // Optional: Auto-hide after some time
                 setTimeout(() => {
                    if (errorPopupContainer.style.display !== 'none') { // Only hide if not already closed
                        errorPopupContainer.style.display = 'none';
                         errorPopupContainer.innerHTML = '';
                    }
                 }, 8000); // Auto-hide after 8 seconds
            }


            function displayFinalReport(report) {
                const reportElement = document.createElement('div');
                reportElement.classList.add('final-report'); // Animation applied via CSS
                 // Basic formatting - use the same safe approach as displayMessage
                 const reportHTML = report
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                     .replace(/\*(.*?)\*/g, '<em>$1</em>')
                     .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
                     .replace(/`([^`]+)`/g, '<code>$1</code>')
                     .replace(/\n/g, '<br>');
                reportElement.innerHTML = `
                    <div class="final-report-title"><i class="fas fa-file-alt"></i> Final Report</div>
                    <div>${reportHTML}</div>
                `;
                chatMessages.appendChild(reportElement);
                chatMessages.scrollTo({ top: chatMessages.scrollHeight, behavior: 'smooth' });
            }

            function showLoading() { loadingIndicator.style.display = 'flex'; }
            function hideLoading() { loadingIndicator.style.display = 'none'; }

           // --- End Helper Functions ---


          // --- Settings UI Functions ---

          // Creates input fields for a role (used by populateSettings)
          function createSettingsInputFields(roleKey, modelType, systemPrompt, parentElement, isDefault = true) {
                const roleContainer = document.createElement('div');
                roleContainer.className = `settings-role-group ${isDefault ? 'default-role' : 'custom-role'}`;
                roleContainer.dataset.role = roleKey; // Store the original key

                const roleTitle = document.createElement('h4');
                roleTitle.textContent = roleKey.charAt(0).toUpperCase() + roleKey.slice(1).replace(/_/g, ' '); // Make readable
                roleContainer.appendChild(roleTitle);

                // Model Input
                const modelLabel = document.createElement('label');
                modelLabel.textContent = 'Model Name';
                modelLabel.htmlFor = `model-${roleKey}`;
                const modelInput = document.createElement('input');
                modelInput.type = 'text';
                modelInput.id = `model-${roleKey}`;
                modelInput.value = modelType || ''; // Handle potential undefined
                modelInput.dataset.settingType = 'model_types';
                modelInput.placeholder = 'e.g., gemini-2.0-flash-lite-001';
                roleContainer.appendChild(modelLabel);
                roleContainer.appendChild(modelInput);

                // Prompt Textarea
                const promptLabel = document.createElement('label');
                promptLabel.textContent = 'System Prompt';
                promptLabel.htmlFor = `prompt-${roleKey}`;
                const promptTextarea = document.createElement('textarea');
                promptTextarea.id = `prompt-${roleKey}`;
                promptTextarea.value = systemPrompt || ''; // Handle potential undefined
                promptTextarea.rows = 5; // Slightly larger default size
                promptTextarea.dataset.settingType = 'system_prompts';
                promptTextarea.placeholder = 'Describe the role\'s goals and responsibilities...';
                roleContainer.appendChild(promptLabel);
                roleContainer.appendChild(promptTextarea);

                // Remove Button (for all roles now)
                const removeButton = document.createElement('button');
                removeButton.textContent = 'Remove Role';
                removeButton.className = `remove-role-button ${isDefault ? 'remove-default-role-button' : ''}`;
                if (isDefault) {
                    removeButton.title = "Removing default roles might break the core collaboration logic."; // Tooltip warning
                }
                roleContainer.appendChild(removeButton);

                parentElement.appendChild(roleContainer);
          }

          // Renders the input fields for a NEW custom role (used by Add New button)
          function renderCustomRoleInput(container) {
                // Use a more robust temporary key for unsaved roles
                const roleKey = `newRole_${Date.now()}`;

                const roleContainer = document.createElement('div');
                roleContainer.className = 'settings-role-group custom-role new-custom-role-input';
                // Do not set data-role until saved with a proper name
                 roleContainer.dataset.tempKey = roleKey; // Mark as temporary

                // Role Name Input (Required)
                const nameLabel = document.createElement('label');
                nameLabel.textContent = 'New Role Name *';
                nameLabel.htmlFor = `name-${roleKey}`;
                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.id = `name-${roleKey}`;
                nameInput.placeholder = 'e.g., planner (use underscores for spaces)';
                nameInput.className = 'new-role-name-input'; // Specific class for identification
                nameInput.required = true;
                roleContainer.appendChild(nameLabel);
                roleContainer.appendChild(nameInput);

                // Model Input
                const modelLabel = document.createElement('label');
                modelLabel.textContent = 'Model Name';
                modelLabel.htmlFor = `model-${roleKey}`;
                const modelInput = document.createElement('input');
                modelInput.type = 'text';
                modelInput.id = `model-${roleKey}`;
                modelInput.value = 'gemini-2.0-flash-lite-001'; // Default new model
                modelInput.dataset.settingType = 'model_types';
                modelInput.placeholder = 'e.g., gemini-2.0-flash-lite-001';
                roleContainer.appendChild(modelLabel);
                roleContainer.appendChild(modelInput);

                // Prompt Textarea (Required)
                const promptLabel = document.createElement('label');
                promptLabel.textContent = 'System Prompt *';
                promptLabel.htmlFor = `prompt-${roleKey}`;
                const promptTextarea = document.createElement('textarea');
                promptTextarea.id = `prompt-${roleKey}`;
                promptTextarea.placeholder = 'Describe the role and responsibilities...';
                promptTextarea.rows = 5;
                promptTextarea.required = true;
                promptTextarea.dataset.settingType = 'system_prompts';
                roleContainer.appendChild(promptLabel);
                roleContainer.appendChild(promptTextarea);

                // Remove Button for the new role input
                const removeButton = document.createElement('button');
                removeButton.textContent = 'Cancel Add'; // More accurate label before saving
                removeButton.className = 'remove-role-button cancel-new-role'; // Specific class
                roleContainer.appendChild(removeButton);

                container.appendChild(roleContainer);
                nameInput.focus(); // Focus on the name field
          }


          // Populates the entire settings UI
          function populateSettings(settingsData) {
              settingsContent.innerHTML = ''; // Clear previous content

              // --- API Key Section ---
              const apiDiv = document.createElement('div');
              apiDiv.className = 'settings-section';
              const apiTitle = document.createElement('h3');
              apiTitle.innerHTML = '<i class="fas fa-key"></i> API Keys';
              apiDiv.appendChild(apiTitle);

              const apiFieldsDiv = document.createElement('div'); // Container for fields
              apiFieldsDiv.className = 'settings-fields'; // Add class if needed for styling

              // Add API key for Google
              const googleApiKeyLabel = document.createElement('label');
              googleApiKeyLabel.textContent = 'Google API Key';
              // Use a consistent ID format
              googleApiKeyLabel.htmlFor = 'setting-api-google-key';
              const googleApiKeyInput = document.createElement('input');
              googleApiKeyInput.type = 'text';
              googleApiKeyInput.id = 'setting-api-google-key'; // Match label's htmlFor
              googleApiKeyInput.value = settingsData.api_keys?.google || ''; // Safely access
              googleApiKeyInput.placeholder = 'Enter your Google API Key';

              apiFieldsDiv.appendChild(googleApiKeyLabel);
              apiFieldsDiv.appendChild(googleApiKeyInput);
              apiDiv.appendChild(apiFieldsDiv);

              // Add API key for OpenAI
              const openaiApiKeyLabel = document.createElement('label');
              openaiApiKeyLabel.textContent = 'OpenAI API Key';
              openaiApiKeyLabel.htmlFor = 'setting-api-openai-key';
              const openaiApiKeyInput = document.createElement('input');
              openaiApiKeyInput.type = 'text';
              openaiApiKeyInput.id = 'setting-api-openai-key';
              openaiApiKeyInput.value = settingsData.api_keys?.openai || '';
              openaiApiKeyInput.placeholder = 'Enter your OpenAI API Key';
              apiFieldsDiv.appendChild(openaiApiKeyLabel);
              apiFieldsDiv.appendChild(openaiApiKeyInput);
              apiDiv.appendChild(apiFieldsDiv);

              // Model Provider Selection for each role
              DEFAULT_ROLES.forEach(role => {
                  const providerLabel = document.createElement('label');
                  providerLabel.textContent = `Select Model Provider for ${role}`;
                  providerLabel.htmlFor = `provider-${role}`;
                  const providerSelect = document.createElement('select');
                  providerSelect.id = `provider-${role}`;
                  providerSelect.dataset.settingType = 'model_provider'; // For easy retrieval
                  providerSelect.dataset.role = role; // Link to role

                  // Populate the provider select options
                  Object.keys(MODEL_PROVIDERS).forEach(providerKey => {
                      const option = document.createElement('option');
                      option.value = providerKey;
                      option.textContent = MODEL_PROVIDERS[providerKey].name;
                      // Set selected based on the current default or settings
                      if (providerKey === settingsData.model_providers?.[role] || providerKey === DEFAULT_PROVIDERS[role]) {
                          option.selected = true;
                      }
                      providerSelect.appendChild(option);
                  });

                  apiFieldsDiv.appendChild(providerLabel);
                  apiFieldsDiv.appendChild(providerSelect);
              });

              apiDiv.appendChild(apiFieldsDiv);

              settingsContent.appendChild(apiDiv);
              // --- End API Key Section ---


              // --- Agent Roles Section (Combined Default and Custom) ---
              const rolesDiv = document.createElement('div');
              rolesDiv.className = 'settings-section';
              const rolesTitle = document.createElement('h3');
              rolesTitle.innerHTML = '<i class="fas fa-users-cog"></i> Agent Roles & Models';
              rolesDiv.appendChild(rolesTitle);

              // Container for all role groups (default + custom)
              const rolesFieldsContainer = document.createElement('div');
              rolesFieldsContainer.id = 'agent-roles-fields'; // ID for event delegation
              rolesDiv.appendChild(rolesFieldsContainer);

               // Render Default Roles (always show, even if data is somehow missing)
              const defaultRolesContainer = document.createElement('div');
              defaultRolesContainer.id = 'default-roles-container';
              const defaultRolesTitle = document.createElement('h4');
              defaultRolesTitle.textContent = 'Default Roles';
              defaultRolesTitle.style.marginTop = '0'; // Reset margin if needed
              defaultRolesContainer.appendChild(defaultRolesTitle);

              DEFAULT_ROLES.forEach(role => {
                  createSettingsInputFields(
                      role,
                      settingsData.model_types?.[role] ?? MODEL_TYPES[role], // Fallback to constant default
                      settingsData.system_prompts?.[role] ?? DEFAULT_SYSTEM_PROMPTS[role] ?? `Default prompt for ${role}`, // Fallback
                      defaultRolesContainer,
                      true // isDefault = true
                  );
              });
              rolesFieldsContainer.appendChild(defaultRolesContainer);


              // Divider
              const divider = document.createElement('hr');
              divider.style.margin = '25px 0'; // More spacing
              rolesFieldsContainer.appendChild(divider);


              // Render Custom Roles
              const customRolesContainer = document.createElement('div');
              customRolesContainer.id = 'custom-roles-container'; // Target for adding new roles
              const customRolesTitle = document.createElement('h4');
              customRolesTitle.textContent = 'Custom Roles';
              customRolesContainer.appendChild(customRolesTitle);


              let hasCustomRoles = false;
              for (const role in settingsData.model_types) {
                  // Check if it's not a default role
                  if (!DEFAULT_ROLES.includes(role)) {
                      // Ensure prompt also exists for this custom role
                      if (settingsData.system_prompts.hasOwnProperty(role)) {
                           createSettingsInputFields(
                               role,
                               settingsData.model_types[role],
                               settingsData.system_prompts[role],
                               customRolesContainer,
                               false // isDefault = false
                           );
                           hasCustomRoles = true;
                      } else {
                          console.warn(`Custom role "${role}" found in model_types but missing from system_prompts. Skipping.`);
                      }
                  }
              }
               // Optional: Display a message if no custom roles exist
              if (!hasCustomRoles) {
                   const noCustomMsg = document.createElement('p');
                   noCustomMsg.textContent = 'No custom roles defined yet.';
                   noCustomMsg.style.color = 'var(--gray)';
                   noCustomMsg.style.fontSize = '0.9em';
                   customRolesContainer.appendChild(noCustomMsg);
              }

              rolesFieldsContainer.appendChild(customRolesContainer);


              // --- "Add New Role" Button (placed after custom roles) ---
              const addRoleButton = document.createElement('button');
              addRoleButton.id = 'add-new-role-button';
              addRoleButton.innerHTML = '<i class="fas fa-plus-circle"></i> Add New Agent Role';
              rolesFieldsContainer.appendChild(addRoleButton); // Append to the main roles container


              // Event listener for "Add New Role" button
              addRoleButton.addEventListener('click', () => {
                   const container = document.getElementById('custom-roles-container');
                   const noCustomMsg = container.querySelector('p'); // Find the 'no custom roles' message
                    if (noCustomMsg) {
                       noCustomMsg.remove(); // Remove the message when adding the first custom role input
                    }
                   if (container) {
                     renderCustomRoleInput(container);
                   } else {
                     console.error("Custom roles container not found");
                     showToast("Error: Could not find where to add the new role.", "error");
                   }
              });

              // Use event delegation for remove/cancel buttons within the roles container
               rolesFieldsContainer.addEventListener('click', function(event) {
                   const button = event.target.closest('.remove-role-button');
                   if (button) {
                       const roleGroup = button.closest('.settings-role-group');
                       if (roleGroup) {
                            const roleName = roleGroup.dataset.role || roleGroup.querySelector('.new-role-name-input')?.value || 'New Role';
                           if (button.classList.contains('cancel-new-role')) {
                               roleGroup.remove(); // Just remove the unsaved input fields
                               showToast("Adding new role cancelled.", "info");
                           } else {
                               // Confirm removal for existing roles (especially default)
                               const isDefault = roleGroup.classList.contains('default-role');
                                const confirmMsg = isDefault
                                    ? `Are you sure you want to remove the default role "${roleName}"? This might break functionality. Save Settings to confirm.`
                                    : `Role "${roleName}" will be removed when you Save Settings.`;

                               if (isDefault && !confirm(`WARNING: ${confirmMsg}\n\nProceed with removal?`)) {
                                   return; // User cancelled deletion of default role
                               }

                               roleGroup.remove(); // Remove from UI immediately
                                showToast(confirmMsg, isDefault ? "error" : "info"); // Use error level for default removal warning
                                // The actual removal from `settings` happens during saveSettingsButton click
                           }
                           // Check if custom roles container is now empty and add message back
                            const customContainer = document.getElementById('custom-roles-container');
                            if (customContainer && customContainer.querySelectorAll('.settings-role-group.custom-role').length === 0) {
                                const noCustomMsg = document.createElement('p');
                                noCustomMsg.textContent = 'No custom roles defined yet.';
                                noCustomMsg.style.color = 'var(--gray)';
                                noCustomMsg.style.fontSize = '0.9em';
                                // Add after the h4 title
                                customContainer.insertBefore(noCustomMsg, customContainer.querySelector('#add-new-role-button'));
                           }
                       }
                   }
               });

              settingsContent.appendChild(rolesDiv); // Add the roles section to the main settings content
              // --- End Agent Roles Section ---


              // --- Collaboration Settings Section ---
              const collabDiv = document.createElement('div');
              collabDiv.className = 'settings-section';
              const collabTitle = document.createElement('h3');
              collabTitle.innerHTML = '<i class="fas fa-cogs"></i> Collaboration Settings'; // Or a more relevant icon
              collabDiv.appendChild(collabTitle);

              const roundsLabel = document.createElement('label');
              roundsLabel.textContent = 'Maximum Rounds';
              roundsLabel.htmlFor = 'setting-max-rounds';
              const roundsInput = document.createElement('input');
              roundsInput.type = 'number';
              roundsInput.id = 'setting-max-rounds';
              roundsInput.value = settingsData.max_rounds || DEFAULT_ROUNDS; // Use setting or default
              roundsInput.min = 1; // Minimum rounds
              roundsInput.step = 1;
              roundsInput.dataset.settingType = 'max_rounds'; // Mark for easy retrieval

              collabDiv.appendChild(roundsLabel);
              collabDiv.appendChild(roundsInput);
              settingsContent.appendChild(collabDiv);
              // --- End Collaboration Settings Section ---
          }


          // Gets settings from UI, including validating and handling new custom roles
          function getSettingsFromUI() {
                const newSettings = {
                    api_keys: {}, model_types: {}, system_prompts: {}, max_rounds: DEFAULT_ROUNDS
                };
                let isValid = true; // Flag to track overall validity

                // --- Get API Key ---
                const apiKeyInput = document.getElementById('setting-api-google-key');
                if (apiKeyInput) {
                    newSettings.api_keys.google = apiKeyInput.value.trim();
                     // Basic check - more robust validation might be needed
                     if (!newSettings.api_keys.google) {
                        // Don't block saving entirely for just API key, but warn
                        showToast("Warning: Google API key is empty.", "error");
                        // isValid = false; // Uncomment if API key should block saving
                     } else if (newSettings.api_keys.google === "YOUR_API_KEY") {
                         showToast("Warning: Using placeholder API key.", "error");
                     }
                } else {
                    console.error("API Key input field not found!");
                    isValid = false;
                }


                // --- Get Role Settings ---
                const allRoleGroups = settingsContent.querySelectorAll('#agent-roles-fields .settings-role-group');
                const processedRoleNames = new Set(); // Track names to detect duplicates

                allRoleGroups.forEach(group => {
                    let roleName;
                    let isNewRole = false;
                    const roleNameInput = group.querySelector('.new-role-name-input');

                    if (roleNameInput) { // This is a new role being added
                        isNewRole = true;
                        roleName = roleNameInput.value.trim().toLowerCase().replace(/\s+/g, '_'); // Sanitize name

                        // Validation for NEW roles
                        if (!roleName) {
                             showToast("Skipping new role: Name cannot be empty.", "error"); isValid = false; return; // Skip this group
                        }
                        if (DEFAULT_ROLES.includes(roleName)) {
                             showToast(`Skipping new role: Name "${roleName}" is reserved. Choose a different name.`, "error"); isValid = false; return;
                        }
                        if (processedRoleNames.has(roleName)) {
                             showToast(`Skipping new role: Duplicate name "${roleName}" found.`, "error"); isValid = false; return;
                        }

                    } else { // Existing role (default or custom)
                        roleName = group.dataset.role;
                         if (!roleName) {
                            console.warn("Role group found without a data-role attribute. Skipping.");
                            return; // Skip if role name is missing
                         }
                    }

                     // Ensure we don't process the same role name twice if UI somehow duplicates it
                     if (processedRoleNames.has(roleName) && !isNewRole) {
                         console.warn(`Duplicate processing attempt for existing role: ${roleName}. Skipping.`);
                         return;
                     }


                    // Get Model and Prompt for this role
                    const modelInput = group.querySelector(`input[data-setting-type="model_types"]`);
                    const promptTextarea = group.querySelector(`textarea[data-setting-type="system_prompts"]`);

                    if (modelInput && promptTextarea) {
                        const modelType = modelInput.value.trim();
                        const systemPrompt = promptTextarea.value.trim();

                        // Validation
                        if (!modelType) {
                             showToast(`Role "${roleName}" skipped: Model Name cannot be empty.`, "error"); isValid = false; return;
                        }
                        if (!systemPrompt) {
                             // Allow empty prompts for existing roles, but warn? Or enforce? Let's enforce for now.
                             showToast(`Role "${roleName}" skipped: System Prompt cannot be empty.`, "error"); isValid = false; return;
                        }

                        // Add valid settings
                        newSettings.model_types[roleName] = modelType;
                        newSettings.system_prompts[roleName] = systemPrompt;
                        processedRoleNames.add(roleName); // Mark as processed

                    } else {
                         console.error(`Could not find model/prompt inputs for role: ${roleName}`);
                          isValid = false; // Critical error if inputs are missing
                    }
                });

                 // Final check: Ensure all DEFAULT roles are still present after potential removals
                 for (const defaultRole of DEFAULT_ROLES) {
                     if (!newSettings.model_types.hasOwnProperty(defaultRole)) {
                          showToast(`Cannot save: Default role "${defaultRole}" is missing. Add it back or reset settings.`, "error");
                          isValid = false;
                     }
                 }

                // --- Get Max Rounds ---
                const roundsInput = document.getElementById('setting-max-rounds');
                if (roundsInput) {
                    const roundsValue = parseInt(roundsInput.value, 10);
                    if (!isNaN(roundsValue) && roundsValue > 0) {
                        newSettings.max_rounds = roundsValue;
                    } else {
                        showToast("Invalid Maximum Rounds. Using default.", "warning");
                        newSettings.max_rounds = DEFAULT_ROUNDS; // Fallback to default
                    }
                } else {
                    console.error("Max Rounds input field not found!");
                    isValid = false; // Or handle as needed
                }


                // Return null if validation failed anywhere critical
                return isValid ? newSettings : null;
          }


          function loadSettings() {
              // Optional: Load from localStorage
              let loadedSettings = null;
              // try {
              //     const savedSettings = localStorage.getItem('aiTeamSettings');
              //     if (savedSettings) { loadedSettings = JSON.parse(savedSettings); }
              // } catch (e) {
              //     console.error("Error loading settings from localStorage:", e);
              //     localStorage.removeItem('aiTeamSettings'); // Clear invalid data
              // }

               // Merge loaded settings with defaults, ensuring defaults take precedence if missing
               const currentSettings = {
                   api_keys: { ...settings.api_keys }, // Start with current memory state
                   model_types: { ...settings.model_types },
                   system_prompts: { ...settings.system_prompts },
                   max_rounds: settings.max_rounds || DEFAULT_ROUNDS
               };

               if (loadedSettings) {
                   // Carefully merge loaded data, potentially validating structure
                   currentSettings.api_keys.google = loadedSettings.api_keys?.google || currentSettings.api_keys.google;
                   // Merge models and prompts, keeping existing ones if loaded ones are missing
                    Object.keys(loadedSettings.model_types || {}).forEach(role => {
                        currentSettings.model_types[role] = loadedSettings.model_types[role];
                    });
                    Object.keys(loadedSettings.system_prompts || {}).forEach(role => {
                        currentSettings.system_prompts[role] = loadedSettings.system_prompts[role];
                    });
                    currentSettings.max_rounds = loadedSettings.max_rounds || currentSettings.max_rounds;
               }


              // Crucially, ensure all DEFAULT roles exist, using constants as the ultimate fallback
               for (const role of DEFAULT_ROLES) {
                   if (!currentSettings.model_types.hasOwnProperty(role)) {
                       currentSettings.model_types[role] = MODEL_TYPES[role] || 'gemini-2.0-flash-lite-001';
                        console.warn(`Default role "${role}" model missing, resetting from constants.`);
                   }
                   if (!currentSettings.system_prompts.hasOwnProperty(role)) {
                       currentSettings.system_prompts[role] = DEFAULT_SYSTEM_PROMPTS[role] || `Default prompt for ${role}`;
                        console.warn(`Default role "${role}" prompt missing, resetting from constants.`);
                   }
               }
               // Ensure API key exists
               if (!currentSettings.api_keys.google) {
                    currentSettings.api_keys.google = GOOGLE_API_KEY; // Reset to placeholder if totally missing
               }

              // Update the global settings object
              settings = currentSettings;

              // Populate UI only if it's visible or needs initial population
              if (settingsContainer.style.display === 'block' || !settingsContent.hasChildNodes()) {
                 populateSettings(settings);
              }
          }

          // --- {{Change 7: Confirmation Popup Function}} ---
          function showConfirmationPopup(message, callbackYes, callbackNo) {
              const overlay = document.createElement('div');
              overlay.className = 'popup-overlay show'; // 'show' class to make it visible

              const popupContent = document.createElement('div');
              popupContent.className = 'popup-content';

              const messagePara = document.createElement('p');
              messagePara.textContent = message;
              popupContent.appendChild(messagePara);

              const buttonsDiv = document.createElement('div');
              buttonsDiv.className = 'popup-buttons';

              const yesButton = document.createElement('button');
              yesButton.className = 'popup-button yes';
              yesButton.textContent = 'Yes';
              yesButton.addEventListener('click', () => {
                  callbackYes();
                  closePopup();
              });
              buttonsDiv.appendChild(yesButton);

              const noButton = document.createElement('button');
              noButton.className = 'popup-button no';
              noButton.textContent = 'No';
              noButton.addEventListener('click', () => {
                  callbackNo();
                  closePopup();
              });
              buttonsDiv.appendChild(noButton);

              popupContent.appendChild(buttonsDiv);
              overlay.appendChild(popupContent);
              document.body.appendChild(overlay);

              // Function to close the popup
              function closePopup() {
                  overlay.classList.remove('show'); // Hide the popup
                  overlay.addEventListener('transitionend', () => { // Wait for fade out
                      if (overlay.parentNode) {
                          overlay.parentNode.removeChild(overlay); // Remove from DOM
                      }
                  }, { once: true }); // Remove event listener after first trigger
              }
          }
          // --- End Confirmation Popup ---


          // --- Main Collaboration Logic ---
          async function run_collaboration(user_prompt) {
              showLoading();
              // Clear previous error messages on new run
               if (errorPopupContainer) errorPopupContainer.style.display = 'none';
              displayMessage("Initiating collaboration protocol...", "system");

              let collaboration_state = {
                  original_problem: user_prompt, summary: "Initial state: Planning required.",
                  history: [], round: 0, converged: false, final_report_content: null, current_plan: null,
                   // Results placeholders
                   research_findings: null, analysis_results: null, critique: null
              };

              try {
                  while (collaboration_state.round < settings.max_rounds && !collaboration_state.converged) {
                      collaboration_state.round++;
                      displayMessage(`--- Starting Round ${collaboration_state.round} ---`, "system");

                      // {{Change 9: Confirmation Popup before last round}}
                      if (collaboration_state.round === settings.max_rounds) {
                          await new Promise(resolve => { // Pause execution until popup interaction
                              showConfirmationPopup(
                                  `Approaching final round (${settings.max_rounds}). Continue to final round?`,
                                  () => { resolve(); }, // Yes: continue round
                                  () => { // No: skip to report
                                      collaboration_state.converged = true;
                                      collaboration_state.round = settings.max_rounds; // Ensure loop exit
                                      displayMessage("User opted to finalize report.", "system");
                                      resolve(); // Resolve promise to continue to report generation
                                  }
                              );
                          });
                          if (collaboration_state.converged) break; // Exit loop if user chose 'No'
                      }


                      // 1. Leader: Plan/Refine
                      let leader_task = collaboration_state.round === 1
                          ? `Analyze the user problem: "${collaboration_state.original_problem}". Create an initial, actionable plan with specific tasks for the Researcher and Analyst roles.`
                          : `Review the current state:\nSummary: ${collaboration_state.summary || 'N/A'}\nCritique from previous round: ${collaboration_state.critique || 'N/A'}\nRefine the plan towards the goal: "${collaboration_state.original_problem}". Assign *specific* next tasks. If the goal is met or further rounds are unnecessary, clearly state 'CONVERGENCE ACHIEVED' followed by the final solution summary.`;

                      let [plan_response, leader_error] = await run_agent('leader', leader_task, collaboration_state);
                      if (leader_error) throw new Error(`Leader failed in round ${collaboration_state.round}: ${leader_error}`);
                       if (!plan_response) throw new Error(`Leader returned an empty response in round ${collaboration_state.round}.`);

                       collaboration_state.current_plan = plan_response; // Store the leader's full output

                      // Check for convergence signal
                      const convergenceSignal = "CONVERGENCE ACHIEVED";
                      if (plan_response.toUpperCase().includes(convergenceSignal)) {
                           collaboration_state.converged = true;
                           // Extract summary after the signal
                           const signalIndex = plan_response.toUpperCase().indexOf(convergenceSignal);
                           collaboration_state.summary = plan_response.substring(signalIndex + convergenceSignal.length).trim();
                           displayMessage("Convergence achieved according to Leader. Preparing final report.", "system");
                           break; // Exit the loop
                      } else {
                           // Update summary for the next agent based on the leader's plan if not converged
                           collaboration_state.summary = `Round ${collaboration_state.round} Plan/Status:\n${plan_response}`;
                      }

                      // --- Agent Execution Phase ---
                       // This needs more sophisticated parsing of the leader's plan to assign tasks correctly.
                       // Simple keyword checks are placeholders.
                      let research_needed = /research|gather data|find information/i.test(collaboration_state.current_plan);
                      let analysis_needed = /analy(s|z)e|evaluate|assess|interpret/i.test(collaboration_state.current_plan);

                      // 2. Researcher (Conditional)
                       collaboration_state.research_findings = null; // Reset findings
                      if (research_needed) {
                           // Ideally, extract the specific research task from the plan
                           const research_task = `Based on the Leader's plan ("${collaboration_state.current_plan.substring(0,100)}..."), conduct the necessary research. Provide concise findings.`;
                           let [research_response, research_error] = await run_agent('researcher', research_task, collaboration_state);
                           if (!research_error && research_response) {
                                collaboration_state.research_findings = research_response;
                                collaboration_state.summary += `\n\nResearch Findings:\n${research_response}`; // Append for context
                           } else {
                                console.warn("Researcher phase skipped or failed:", research_error);
                                displayMessage(`*Researcher skipped or failed: ${research_error || 'No response'}*`, 'system');
                            }
                      }

                       // 3. Analyst (Conditional)
                       collaboration_state.analysis_results = null; // Reset results
                       if (analysis_needed) {
                            // Ideally, extract the specific analysis task
                            const analysis_task = `Based on the Leader's plan ("${collaboration_state.current_plan.substring(0,100)}...") and Research Findings (if any: "${(collaboration_state.research_findings || 'None').substring(0,50)}..."), perform the required analysis. Provide clear results or interpretations.`;
                            let [analysis_response, analysis_error] = await run_agent('analyst', analysis_task, collaboration_state);
                           if (!analysis_error && analysis_response) {
                                collaboration_state.analysis_results = analysis_response;
                                collaboration_state.summary += `\n\nAnalysis Results:\n${analysis_response}`; // Append for context
                           } else {
                                console.warn("Analyst phase skipped or failed:", analysis_error);
                                displayMessage(`*Analyst skipped or failed: ${analysis_error || 'No response'}*`, 'system');
                            }
                       }

                      // 4. Synthesizer: Consolidate progress
                       const synth_task = `Integrate the current plan, research findings, and analysis results from this round. Provide an updated, concise summary reflecting the current state of the solution/progress towards the goal: "${collaboration_state.original_problem}". Current Context:\n${collaboration_state.summary}`;
                       let [synth_response, synth_error] = await run_agent('synthesizer', synth_task, collaboration_state);
                      if (synth_error) throw new Error(`Synthesizer failed in round ${collaboration_state.round}: ${synth_error}`);
                       if (!synth_response) throw new Error(`Synthesizer returned empty response in round ${collaboration_state.round}.`);
                      collaboration_state.summary = synth_response; // **Replace** summary with the synthesis


                      // 5. Critic: Review Synthesis
                       collaboration_state.critique = null; // Reset critique
                       const critic_task = `Critically evaluate the Synthesizer's output for this round: "${collaboration_state.summary.substring(0, 200)}...". Identify specific flaws, inconsistencies, risks, or areas needing further refinement related to the main goal: "${collaboration_state.original_problem}". Be constructive.`;
                       let [critique_response, critique_error] = await run_agent('critic', critic_task, collaboration_state);
                      if (critique_error) throw new Error(`Critic failed in round ${collaboration_state.round}: ${critique_error}`);
                       // We don't throw on empty critique, it might be valid if the plan is good
                       collaboration_state.critique = critique_response || "No specific issues identified."; // Store critique for next round's leader


                      displayMessage(`--- End of Round ${collaboration_state.round} ---`, "system");
                  } // End while loop

                  // --- Post-Loop ---
                  if (!collaboration_state.converged && collaboration_state.round >= settings.max_rounds) {
                      displayMessage(`Maximum rounds (${settings.max_rounds}) reached. Generating report based on the current state.`, "system");
                  }

                  // 6. Final Report Generation
                  const final_task = `Generate the final, comprehensive report based on the entire process and the final state achieved. Final State Summary:\n${collaboration_state.summary || 'No conclusive summary available.'}\nOriginal Problem: ${collaboration_state.original_problem}`;
                  let [final_report, report_error] = await run_agent('reporter', final_task, collaboration_state);

                  if (report_error) {
                       // Display error using the popup mechanism
                       displayErrorMessage(`Reporter failed to generate final report: ${report_error}`, 'reporter');
                       // Provide a fallback report in the chat
                       displayFinalReport(`**Reporting Failed**. The collaboration ended. Last known state:\n${collaboration_state.summary || 'No summary available.'}`);
                   } else if (!final_report) {
                       displayErrorMessage(`Reporter returned an empty report.`, 'reporter');
                       displayFinalReport(`**Reporting Issue**. The reporter did not provide content. Last known state:\n${collaboration_state.summary || 'No summary available.'}`);
                   } else {
                      // Display the successful final report
                      displayFinalReport(final_report);
                  }

              } catch (error) {
                  // Catch errors from run_agent or explicit throws
                  console.error("Collaboration critically failed:", error);
                  displayErrorMessage(`Collaboration stopped due to critical error: ${error.message}`, 'System');
                  // Optionally display a minimal failure report in chat
                   displayFinalReport(`**Collaboration Failed**. An error occurred: ${error.message}`);
              } finally {
                  hideLoading(); // Ensure loading indicator is always hidden
              }
          }
          // --- End Main Collaboration Logic ---


          // --- Event Listeners ---
          sendButton.addEventListener('click', async () => {
               const user_prompt = userMessageInput.value.trim();
               if (user_prompt) {
                    // Optional: Clear previous chat messages on new prompt
                    // chatMessages.innerHTML = '';
                    displayMessage(user_prompt, 'user'); // Display user message
                    userMessageInput.value = ''; // Clear input field

                    // Check API Key before starting collaboration
                    if (!settings.api_keys.google || settings.api_keys.google === "YOUR_API_KEY" || settings.api_keys.google.trim() === "") {
                       showToast("Please set your Google API Key in Settings first!", "error");
                       // Optionally open settings automatically
                       if (settingsContainer.style.display !== 'block') {
                           toggleSettingsButton.click(); // Simulate click to open and load
                       }
                       return; // Stop execution
                    }
                   await run_collaboration(user_prompt); // Start the process
               } else {
                   showToast("Please enter a problem or question.", "info"); // Use info for empty input
               }
           });

           userMessageInput.addEventListener('keypress', (e) => {
               // Send on Enter key (but not Shift+Enter for newlines)
               if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // Prevent default newline insertion
                   sendButton.click(); // Trigger send button click
               }
           });

           toggleSettingsButton.addEventListener('click', () => {
               const isHidden = settingsContainer.style.display === 'none' || settingsContainer.style.display === '';
               settingsContainer.style.display = isHidden ? 'block' : 'none';
               if (isHidden) {
                   // Load/refresh settings content when opening
                   loadSettings(); // This will call populateSettings if needed
               }
           });

           saveSettingsButton.addEventListener('click', () => {
                const validatedSettings = getSettingsFromUI(); // This now returns null on validation failure

                if (validatedSettings) {
                    // Validation passed, update the main settings object
                    settings = validatedSettings;

                    // Optional: Save to localStorage
                    // try {
                    //    localStorage.setItem('aiTeamSettings', JSON.stringify(settings));
                    // } catch (e) {
                    //    console.error("Error saving settings to localStorage:", e);
                    //    showToast("Could not save settings locally.", "error");
                    // }

                    settingsContainer.style.display = 'none'; // Close settings panel
                    showToast("Settings saved successfully!", "success");

                     // No need to call loadSettings() here, it will be called when panel is reopened.

                } else {
                    // Validation failed (getSettingsFromUI returned null)
                    showToast("Settings not saved. Please fix the errors indicated.", "error");
                     // Ensure settings panel stays open
                     settingsContainer.style.display = 'block';
                     // Optionally re-populate to highlight issues if needed, but getSettingsFromUI should have shown toasts
                     // populateSettings(settings); // Re-populates with the *last known good* settings
                }
            });
          // --- End Event Listeners ---


          // --- Initialization ---
          loadSettings(); // Load initial settings (from memory/localStorage, ensures defaults)
          displayMessage("Welcome! I am the AI Team Leader. Enter your problem, and my team and I will work on it. Check or configure the API Key and Agent settings via the <i class='fas fa-cog'></i> button.", "leader");
           // Initial API key check - show non-blocking info toast
           if (!settings.api_keys.google || settings.api_keys.google === "YOUR_API_KEY" || settings.api_keys.google.trim() === "") {
               showToast("Google API Key not set. Please configure it in Settings for the AI agents to work.", "info", 6000); // Longer duration info
           }
          // --- End Initialization ---

        });
    </script>

</body>
</html>
